

char misc_tcl_proc[]=
"#!/usr/bin/wish -f\n"
"\n"
"\n"
"\n"
"\n"
"############################################################\n"
"# This routine is called whenever one of the scrollbars is #\n"
"# moved. It adjusts the scroll bar to it's new position    #\n"
"# and updates the associated entry.                        #\n"
"# top and bot indicate the upper and lower limits of the   #\n"
"# scrollbar while path would be something like .xvst.tmax  #\n"
"# It is assumed the scrollbar is at $path.sb and the entry #\n"
"# at $path.en .                                            #\n"
"############################################################\n"
"proc scrollvalue {top bot path how args} {\n"
"   \n"
"   set r [expr $top-$bot]\n"
"   set val [lindex [$path.sb get] 0]\n"
"   set num [lindex $args 0]\n"
"   set del 0\n"
"   \n"
"   switch $how {\n"
"      moveto\n"
"         {set del [expr ($num)-($val)]}\n"
"      scroll\n"
"      {\n"
"         switch [lindex $args 1] {\n"
"            units\n"
"               {set del [expr $num/1000.0]}\n"
"            pages\n"
"               {set del [expr $num/100.0]}\n"
"         }\n"
"      }\n"
"   }\n"
"   set newval [expr $val+$del]\n"
"   $path.sb set $newval $newval\n"
"   set val [lindex [$path.sb get] 0]\n"
"   $path.en delete 0 end\n"
"   \n"
"   # display an appropriate number of decimal points\n"
"   set scale $r\n"
"   if {[expr $scale<0]} then {set scale -$r}\n"
"   if     {[expr $scale<3.0  ]} then {set form \"%.3f\"} \\n"
"   elseif {[expr $scale<10.0 ]} then {set form \"%.2f\"} \\n"
"   elseif {[expr $scale<100.0]} then {set form \"%.1f\"} \\n"
"   else   {set form \"%.0f\"}\n"
"   \n"
"   $path.en insert 0 [format $form [expr (((1.0-$val)*$r)+$bot)]]\n"
"}\n"
"\n"
"##########################################################\n"
"# This routine is called whenever <Return> is pressed    #\n"
"# while editing an entry so that the scroll bar position #\n"
"# will be updated. See \"scrollvalue\" comment for         #\n"
"# description of args.                                   #\n"
"########################################################## \n"
"proc entryvalue {top bot path} {\n"
"\n"
"   set r [expr 1.0*($top-$bot)]\n"
"   \n"
"   set enval [$path.en get]\n"
"   set val [expr 1.0-(($enval-$bot)/$r)]\n"
"   scrollvalue $top $bot $path moveto $val\n"
"\n"
"}\n"
"\n"
"\n"
"##########################################################\n"
"# A little routine to help center toplevel widgets on    #\n"
"# the screen                                             #\n"
"##########################################################\n"
"proc CenterWindow {win} {\n"
"	wm withdraw $win\n"
"	update\n"
"	\n"
"	set screenwidth [winfo screenwidth .]\n"
"	set winwidth [winfo reqwidth $win]\n"
"	set screenheight [winfo screenheight .]\n"
"	set winheight [winfo reqheight $win]\n"
"\n"
"	set x [expr ($screenwidth-$winwidth)/2]\n"
"	set y [expr ($screenheight-$winheight)/2]\n"
"\n"
"	 wm geometry $win +$x+$y\n"
"	 wm deiconify $win\n"
"}\n"
"\n"
"################################################################\n"
"# Calling this routine will start an endless loop of having    #\n"
"# this routine called again and setting the global \"replot\"    #\n"
"# variable so that the screen is continually updated. To kill  #\n"
"# the loop, one needs to execute the following:                #\n"
"#                                                              #\n"
"#	after cancel after idle SetReplotGlobal                     #\n"
"#  after cancel SetReplotGlobal                                #\n"
"################################################################\n"
"proc SetReplotGlobal {} {\n"
"	global replot\n"
"\n"
"	set replot 1\n"
"	after 5000 after idle SetReplotGlobal\n"
"}\n"
"\n"
"\n"
"\n"

;

